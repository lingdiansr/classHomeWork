/*
题目描述
用1,2,...,n表示n个盘子，称为1号盘，2号盘,...。号数大盘子就大。经典的汉诺塔问题经常作为一个递归的经典例题存在。可能有人并不知道汉诺塔问题的典故。汉诺塔来源于印度传说的一个故事，上帝创造世界时作了三根金刚石柱子，在一根柱子上从下往上按大小顺序摞着64片黄金圆盘。上帝命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一回只能移动一个圆盘。我们知道最少需要移动2^64-1次.在移动过程中发现，有的圆盘移动次数多，有的少 。 告之盘子总数和盘号，计算该盘子的移动次数.
输入
包含多组数据，首先输入T,表示有T组数据.每个数据一行，是盘子的数目N(1<=N<=60)和盘号k(1<=k<=N)。
输出
对于每组数据，输出一个数，到达目标时k号盘需要的最少移动数。
样例输入 Copy
2
60 1
3 1
样例输出 Copy
576460752303423488
4*/

#include <stdio.h>
#include<math.h>
int main()
{
    int n, num, id;
    long long step;
    scanf("%d", &num);
    for (int i = 0; i < num; i++)
    {
        scanf("%d %d",&n, &id);
        step = pow(2,n-id);
        printf("%lld\n", step);
    }
    return 0;
}